{"version":3,"sources":["services/ISPTermStorePickerService.ts"],"names":[],"mappings":"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","file":"services/ISPTermStorePickerService.js","sourcesContent":["import { IPickerTerm } from './../propertyFields/termPicker/IPropertyFieldTermPicker';\nimport { findIndex } from '@microsoft/sp-lodash-subset';\n\n/**\n * Interfaces for Term store, groups and term sets\n */\nexport interface ITermStore {\n  _ObjectType_: string; // SP.Taxonomy.TermStore\n  _ObjectIdentity_: string;\n  Id: string;\n  Name: string;\n  Groups: IGroups;\n}\n\n/**\n * Interface to store backward connection between Group and Term store\n */\nexport interface ITermStoreMinimal {\n  Id: string;\n  Name: string;\n}\n\nexport interface IGroups {\n  _ObjectType_: string; // SP.Taxonomy.TermGroupCollection\n  _Child_Items_: IGroup[];\n}\n\nexport interface IGroup {\n  _ObjectType_: string; // SP.Taxonomy.TermGroup\n  _ObjectIdentity_: string;\n  TermSets: ITermSets;\n  Id: string;\n  Name: string;\n  IsSystemGroup: boolean;\n  TermStore?: ITermStoreMinimal;\n}\n\nexport interface ITermSets {\n  _ObjectType_: string; // SP.Taxonomy.TermSetCollection\n  _Child_Items_: ITermSet[];\n}\n\nexport interface ITermSet {\n  _ObjectType_: string; // SP.Taxonomy.TermSet\n  _ObjectIdentity_: string;\n  Id: string;\n  Name: string;\n  Description: string;\n  Names: ITermSetNames;\n  /**\n   * This prop is internal. It is not returned from SP Service.\n   * We need that to store Group Id.\n   */\n  Group?: string;\n}\n\nexport interface ITermSetMinimal {\n  _ObjectType_: string; // SP.Taxonomy.TermSet\n  _ObjectIdentity_: string;\n  Id: string;\n  Name: string;\n}\n\nexport interface ITermSetNames {\n  [locale: string]: string;\n}\n\n/**\n * Interfaces for the terms\n */\nexport interface ITerms {\n  _ObjectType_: string; // SP.Taxonomy.TermCollection\n  _Child_Items_: ITerm[];\n}\n\n/**\n * Term\n */\nexport interface ITerm {\n  _ObjectType_: string; // SP.Taxonomy.Term\n  _ObjectIdentity_: string;\n  Id: string;\n  Name: string;\n  Description: string;\n  IsDeprecated: boolean;\n  IsAvailableForTagging: boolean;\n  IsRoot: boolean;\n  PathOfTerm: string;\n  TermSet: ITermSetMinimal;\n  PathDepth?: number;\n  Labels?: string[];\n}\n\n/**\n * Properties for the Term Store Picker Service\n */\nexport interface ISPTermStorePickerServiceProps {\n  limitByGroupNameOrID?: string;\n  limitByTermsetNameOrID?: string;\n  excludeSystemGroup?: boolean;\n}\n\n/**\n * Properties for the Enterprise Term Store Picker Service\n */\nexport interface IPnPTermStorePickerServiceProps extends ISPTermStorePickerServiceProps {\n  /**\n   * Specifies if term labels should be loaded from the store\n   */\n  includeLabels?: boolean;\n}\n\n/**\n * Interface to be implemented by Term Store Picker Services\n */\nexport interface ISPTermStorePickerService {\n  /**\n   * Searches terms by provided text\n   */\n  searchTermsByName: (searchText: string) => Promise<IPickerTerm[]>;\n  /**\n   * Gets term sets from the stores\n   */\n  getTermSets: () => Promise<ITermSet[]>;\n  /**\n   * Get term sets from the specified group\n   */\n  getGroupTermSets: (group: IGroup) => Promise<ITermSets>;\n  /**\n   * Gets all terms from the specified term set\n   */\n  getAllTerms: (termSet: ITermSet) => Promise<ITerm[]>;\n  /**\n   * Gets term stores from the taxonomy service\n   */\n  getTermStores: () => Promise<ITermStore[]>;\n}\n\n/**\n * Helper class with some methods that can be used in any Term Store Picker Service implementation\n */\nexport class TermStorePickerServiceHelper {\n  /**\n   * Cleans the Guid from the Web Service response\n   * @param guid\n   */\n  public static cleanGuid(guid: string): string {\n    if (guid !== undefined) {\n      return guid.replace('/Guid(', '').replace('/', '').replace(')', '');\n    } else {\n      return '';\n    }\n  }\n\n  /**\n   * Checks if the provided string is a GUID\n   * @param strGuid string to check\n   */\n  public static isGuid(strGuid: string): boolean {\n    return /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(strGuid);\n  }\n\n  /**\n   * Sorting terms based on their path and depth\n   *\n   * @param terms\n   */\n  public static sortTerms(terms: ITerm[]) {\n    // Start sorting by depth\n    let newTermsOrder: ITerm[] = [];\n    let itemsToSort = true;\n    let pathLevel = 1;\n    while (itemsToSort) {\n      // Get terms for the current level\n      let crntTerms = terms.filter(term => term.PathDepth === pathLevel);\n      if (crntTerms && crntTerms.length > 0) {\n        crntTerms = crntTerms.sort(this.sortTermByPath);\n\n        if (pathLevel !== 1) {\n          crntTerms = crntTerms.reverse();\n          for (const crntTerm of crntTerms) {\n            const pathElms = crntTerm.PathOfTerm.split(\";\");\n            // Last item is not needed for parent path\n            pathElms.pop();\n            // Find the parent item and add the new item\n            const idx = findIndex(newTermsOrder, term => term.PathOfTerm === pathElms.join(\";\"));\n            if (idx !== -1) {\n              newTermsOrder.splice(idx + 1, 0, crntTerm);\n            } else {\n              // Push the item at the end if the parent couldn't be found\n              newTermsOrder.push(crntTerm);\n            }\n          }\n        } else {\n          newTermsOrder = crntTerms;\n        }\n\n        ++pathLevel;\n      } else {\n        itemsToSort = false;\n      }\n    }\n    return newTermsOrder;\n  }\n\n  /**\n   * Sort the terms by their path\n   *\n   * @param a term 2\n   * @param b term 2\n   */\n  private static sortTermByPath(a: ITerm, b: ITerm) {\n    if (a.PathOfTerm < b.PathOfTerm) {\n      return -1;\n    }\n    if (a.PathOfTerm > b.PathOfTerm) {\n      return 1;\n    }\n    return 0;\n  }\n}\n"],"sourceRoot":"../../src"}