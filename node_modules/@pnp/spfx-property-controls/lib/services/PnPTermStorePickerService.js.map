{"version":3,"sources":["services/PnPTermStorePickerService.ts"],"names":[],"mappings":"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","file":"services/PnPTermStorePickerService.js","sourcesContent":["import {\n    ISPTermStorePickerService,\n    IPnPTermStorePickerServiceProps,\n    ITermStore,\n    ITermSet,\n    TermStorePickerServiceHelper,\n    ITerm,\n    IGroup,\n    ITermSets\n} from \"./ISPTermStorePickerService\";\nimport { IWebPartContext } from \"@microsoft/sp-webpart-base\";\nimport {\n    taxonomy,\n    ITermStore as PnPTermStore,\n    ITermStoreData,\n    StringMatchOption,\n    ITermSet as PnPTermSet,\n    ITermSetData,\n    ITermGroupData,\n    ITermGroup as PnPTermGroup,\n    ITermData,\n    ITerm as PnPTerm,\n    Terms\n} from \"@pnp/sp-taxonomy\";\nimport { IPickerTerm } from './../propertyFields/termPicker/IPropertyFieldTermPicker';\nimport { Environment, EnvironmentType } from \"@microsoft/sp-core-library\";\nimport SPTermStoreMockHttpClient from \"./SPTermStorePickerMockService\";\n\n/**\n * Term Store Picker Service implementation that uses @pnp/sp-taxonomy to work with taxonomy service\n */\nexport default class PnPTermStorePickerService implements ISPTermStorePickerService {\n\n    private readonly _termSetCollectionObjectType: string = 'SP.Taxonomy.TermSetCollection';\n    private readonly _termGroupCollectionObjectType: string = 'SP.Taxonomy.TermGroupCollection';\n\n    private _pnpTermStores: (ITermStoreData & PnPTermStore)[];\n    private _pnpGroups: { [termStoreId: string]: (ITermGroupData & PnPTermGroup)[] } = {};\n\n    constructor(private props: IPnPTermStorePickerServiceProps, private context: IWebPartContext) {\n        taxonomy.setup({\n            spfxContext: context\n            //globalCacheDisable: true // uncomment this one for debugging with no cache\n        });\n    }\n\n    /**\n     * Gets term stores from the taxonomy service\n     */\n    public async getTermStores(): Promise<ITermStore[]> {\n        if (Environment.type === EnvironmentType.Local) {\n            // If the running environment is local, load the data from the mock\n            return await SPTermStoreMockHttpClient.getTermStores(this.context.pageContext.web.absoluteUrl) as ITermStore[];\n        }\n        else {\n            await this._ensureTermStores();\n\n            const result: ITermStore[] = [];\n            this._pnpTermStores.forEach(pnpTermStore => {\n                const pnpTermStoreAny: any = pnpTermStore as any;\n                result.push({\n                    _ObjectType_: 'SP.Taxonomy.TermStore',\n                    _ObjectIdentity_: pnpTermStoreAny._ObjectIdentity_,\n                    Id: pnpTermStore.Id,\n                    Name: pnpTermStore.Name,\n                    Groups: {\n                        _ObjectType_: this._termGroupCollectionObjectType,\n                        _Child_Items_: this._pnpGroups[pnpTermStore.Id].map(g => {\n                            return this._pnpTermGroup2TermGroup(g, pnpTermStore);\n                        })\n                    }\n                });\n            });\n\n            return result;\n        }\n    }\n\n    /**\n     * Searches terms by provided text\n     * @param searchText text to search\n     */\n    public async searchTermsByName(searchText: string): Promise<IPickerTerm[]> {\n        if (Environment.type === EnvironmentType.Local) {\n            // If the running environment is local, load the data from the mock\n            return SPTermStoreMockHttpClient.searchTermsByName(searchText);\n        } else {\n            if (this.props.limitByTermsetNameOrID) { // search in specific term(s)\n                return this._searchTermsByTermSet(searchText);\n            } else if (this.props.limitByGroupNameOrID) { // search in specific group\n                return this._searchTermsByGroup(searchText);\n            } else { // search everywhere\n                return this._searchAllTerms(searchText);\n            }\n        }\n    }\n\n    /**\n     * Gets term sets from the stores\n     */\n    public async getTermSets(): Promise<ITermSet[]> {\n        let termSets: ITermSet[] = [];\n\n        //\n        // for local tests\n        //\n        if (Environment.type === EnvironmentType.Local) {\n            const termStores = await SPTermStoreMockHttpClient.getTermStores(this.context.pageContext.web.absoluteUrl) as ITermStore[];\n            if (termStores && termStores.length > 0) {\n                // Get the first term store\n                const ts = termStores[0];\n                // Check if the term store contains groups\n                if (ts.Groups && ts.Groups._Child_Items_) {\n                    for (const group of ts.Groups._Child_Items_) {\n                        // Check if the group contains term sets\n                        if (group.TermSets && group.TermSets._Child_Items_) {\n                            if (this.props.limitByTermsetNameOrID) {\n                                for (const termSet of group.TermSets._Child_Items_) {\n                                    // Check if the term set is found\n                                    if (termSet.Name === this.props.limitByTermsetNameOrID || termSet.Id.indexOf(this.props.limitByTermsetNameOrID) !== -1) {\n                                        termSets = [...termSets, termSet];\n                                    }\n                                }\n                            } else {\n                                termSets = [...termSets, ...group.TermSets._Child_Items_];\n                            }\n                        }\n                    }\n                }\n            }\n            return termSets;\n        }\n\n        await this._ensureTermStores();\n\n        for (let i = 0, len = this._pnpTermStores.length; i < len; i++) {\n            const pnpTermStore = this._pnpTermStores[i];\n\n            if (this.props.limitByTermsetNameOrID) {\n                let pnpTermSets = await this._getPnPTermSetsByNameOrId(pnpTermStore, this.props.limitByTermsetNameOrID);\n\n                const groupsBatch = taxonomy.createBatch();\n\n                for (let termSetIdx = 0, termSetLen = pnpTermSets.length; termSetIdx < termSetLen; termSetIdx++) {\n                    const pnpTermSet = pnpTermSets[termSetIdx];\n                    const termSet: ITermSet = this._pnpTermSet2TermSet(pnpTermSet, '');\n                    termSets.push(termSet);\n                    pnpTermSet.group.inBatch(groupsBatch).usingCaching().get().then(pnpTermGroup => {\n                        termSet.Group = TermStorePickerServiceHelper.cleanGuid(pnpTermGroup.Id);\n                    });\n                }\n\n                await groupsBatch.execute();\n            }\n            else {\n                let pnpGroups: (ITermGroupData & PnPTermGroup)[];\n                if (this.props.limitByGroupNameOrID) {\n                    const pnpGroup = this._getPnPTermGroupsByNameOrId(pnpTermStore.Id, this.props.limitByGroupNameOrID);\n                    pnpGroups = [];\n\n                    if (pnpGroup) {\n                        pnpGroups.push(pnpGroup);\n                    }\n                }\n                else {\n                    pnpGroups = this._pnpGroups[pnpTermStore.Id];\n                }\n\n                const batch = taxonomy.createBatch();\n\n                pnpGroups.forEach(pnpGroup => {\n                    pnpGroup.termSets.inBatch(batch).usingCaching().get().then(pnpTermSets => {\n                        termSets = [...termSets, ...pnpTermSets.map(pnpTermSet => {\n                            return this._pnpTermSet2TermSet(pnpTermSet, TermStorePickerServiceHelper.cleanGuid(pnpGroup.Id));\n                        })];\n                    });\n                });\n\n                await batch.execute();\n            }\n        }\n\n        return termSets;\n    }\n\n    /**\n     * Gets all terms from the specified term set\n     * @param termSet Term Set to get terms from\n     */\n    public async getAllTerms(termSet: ITermSet): Promise<ITerm[]> {\n        if (Environment.type === EnvironmentType.Local) {\n            // If the running environment is local, load the data from the mock\n            return SPTermStoreMockHttpClient.getAllTerms();\n        }\n        await this._ensureTermStores();\n        const pnpTermStores = this._pnpTermStores;\n        for (const pnpTermStore of pnpTermStores) {\n            const termsResult: any = await this._tryGetAllTerms(pnpTermStore, termSet).catch((error) => { }); // .catch part is needed to proceed if there was a rejected promise\n            if (!termsResult) { // terms variable will be undefined if the Promise has been rejected. Otherwise it will contain an array\n                continue;\n            }\n\n            const pnpTerms: (ITermData & PnPTerm)[] = termsResult as (ITermData & PnPTerm)[];\n            const resultTerms: ITerm[] = [];\n            const labelsBatch = taxonomy.createBatch();\n\n            for (let termIdx = 0, termsLen = pnpTerms.length; termIdx < termsLen; termIdx++) {\n                const pnpTerm = pnpTerms[termIdx];\n\n                const term: ITerm = (pnpTerm as any) as ITerm;\n                term.Id = TermStorePickerServiceHelper.cleanGuid(term.Id);\n                term.PathDepth = term.PathOfTerm.split(';').length;\n                term.TermSet = termSet;\n\n                resultTerms.push(term);\n\n                if (this.props.includeLabels) {\n                    pnpTerm.labels.inBatch(labelsBatch).usingCaching().get().then(labels => {\n                        term.Labels = labels.map(label => label.Value);\n                    });\n                }\n            }\n\n            if (this.props.includeLabels) {\n                await labelsBatch.execute();\n            }\n\n            return TermStorePickerServiceHelper.sortTerms(resultTerms);\n        }\n\n    }\n\n    /**\n     * Get term sets from the specified group\n     * @param group Term Group\n     */\n    public async getGroupTermSets(group: IGroup): Promise<ITermSets> {\n        await this._ensureTermStores();\n        const pnpTermStore = this._pnpTermStores.filter(ts => TermStorePickerServiceHelper.cleanGuid(ts.Id) === group.TermStore.Id)[0];\n\n        const pnpGroups = this._pnpGroups[pnpTermStore.Id].filter(gr => TermStorePickerServiceHelper.cleanGuid(gr.Id) === group.Id); //await pnpTermStore.getTermGroupById(group.Id).usingCaching().get();\n        if (!pnpGroups || !pnpGroups.length) {\n            return {\n                _ObjectType_: this._termSetCollectionObjectType,\n                _Child_Items_: []\n            };\n        }\n        const pnpGroup = pnpGroups[0];\n        let pnpTermSets: (ITermSetData & PnPTermSet)[];\n        if (this.props.limitByTermsetNameOrID) {\n            const isGuid: boolean = TermStorePickerServiceHelper.isGuid(this.props.limitByTermsetNameOrID);\n            if (isGuid) {\n                pnpTermSets = [await pnpGroup.termSets.getById(this.props.limitByTermsetNameOrID).usingCaching().get()];\n            }\n            else {\n                pnpTermSets = [await pnpGroup.termSets.getByName(this.props.limitByTermsetNameOrID).usingCaching().get()];\n            }\n        }\n        else {\n            pnpTermSets = await pnpGroup.termSets.usingCaching().get();\n        }\n\n        const result: ITermSets = {\n            _ObjectType_: this._termSetCollectionObjectType,\n            _Child_Items_: pnpTermSets.map(pnpTermSet => {\n                return this._pnpTermSet2TermSet(pnpTermSet, TermStorePickerServiceHelper.cleanGuid(pnpGroup.Id));\n            })\n        };\n\n        return result;\n    }\n\n    /**\n     * Tries to get terms from the specified Term Set.\n     * @param pnpTermStore Term Store to work with\n     * @param termSet Term set to get terms from\n     */\n    private _tryGetAllTerms(pnpTermStore: ITermStoreData & PnPTermStore, termSet: ITermSet): Promise<(ITermData & PnPTerm)[]> {\n        return new Promise<(ITermData & PnPTerm)[]>((resolve, reject) => {\n            pnpTermStore.getTermSetById(termSet.Id).terms.usingCaching().get().then((pnpTerms) => {\n                resolve(pnpTerms);\n            }, (error) => {\n                reject(error);\n            });\n        });\n    }\n\n    /**\n     * Searches terms by provided text in the term sets specified by the this.props.limitByTermSetNameOrId\n     * @param searchText text to search\n     */\n    private async _searchTermsByTermSet(searchText: string): Promise<IPickerTerm[]> {\n        if (Environment.type === EnvironmentType.Local) {\n            // If the running environment is local, load the data from the mock\n            return SPTermStoreMockHttpClient.searchTermsByName(searchText);\n        } else {\n            await this._ensureTermStores();\n            let returnTerms: IPickerTerm[] = [];\n            const pnpTermStores = this._pnpTermStores;\n\n            //\n            // iterating through term stores\n            //\n            for (let i = 0, len = pnpTermStores.length; i < len; i++) {\n                const pnpTermStore = pnpTermStores[i];\n                const pnpTermSets = await this._getPnPTermSetsByNameOrId(pnpTermStore, this.props.limitByTermsetNameOrID);\n\n                // getting filtered terms from term sets\n                returnTerms.push(...await this._searchTermsInTermSets(pnpTermStore, pnpTermSets, searchText));\n\n            }\n\n            return returnTerms;\n        }\n    }\n\n    /**\n     * Searches terms by provided text in the term sets specified by the this.props.limitByGroupNameOrId\n     * @param searchText text to search\n     */\n    private async _searchTermsByGroup(searchText: string): Promise<IPickerTerm[]> {\n        if (Environment.type === EnvironmentType.Local) {\n            // If the running environment is local, load the data from the mock\n            return SPTermStoreMockHttpClient.searchTermsByName(searchText);\n        } else {\n            await this._ensureTermStores();\n            const groupNameOrID = this.props.limitByGroupNameOrID;\n            let returnTerms: IPickerTerm[] = [];\n            const pnpTermStores = this._pnpTermStores;\n\n            //\n            // iterating through term stores\n            //\n            for (let i = 0, len = pnpTermStores.length; i < len; i++) {\n                const pnpTermStore = pnpTermStores[i];\n                const pnpGroup = this._getPnPTermGroupsByNameOrId(pnpTermStore.Id, groupNameOrID);\n\n                if (!pnpGroup) {\n                    continue;\n                }\n                // getting term sets from term group\n                const pnpTermSets = await pnpGroup.termSets.usingCaching().get();\n                // getting filtered terms from term sets\n                returnTerms.push(...await this._searchTermsInTermSets(pnpTermStore, pnpTermSets, searchText, pnpGroup.Id));\n            }\n\n            return returnTerms;\n        }\n    }\n\n    /**\n     * Searches for terms in the term store\n     * @param searchText text to search\n     */\n    private async _searchAllTerms(searchText: string): Promise<IPickerTerm[]> {\n        if (Environment.type === EnvironmentType.Local) {\n            // If the running environment is local, load the data from the mock\n            return SPTermStoreMockHttpClient.searchTermsByName(searchText);\n        }\n\n        await this._ensureTermStores();\n\n        const pnpTermStores = this._pnpTermStores;\n        const returnTerms: IPickerTerm[] = [];\n\n        //\n        // iterating through term stores\n        //\n        for (let i = 0, len = pnpTermStores.length; i < len; i++) {\n            const pnpTermStore = pnpTermStores[i];\n\n            // searching for terms that starts with provided string\n            const pnpTerms = await pnpTermStore.getTerms({\n                TermLabel: searchText,\n                StringMatchOption: StringMatchOption.StartsWith,\n                DefaultLabelOnly: true,\n                TrimUnavailable: true,\n                ResultCollectionSize: 30\n            }).usingCaching().get();\n\n            const batch = taxonomy.createBatch();\n\n            //\n            // processing each term to get termSet info and labels\n            //\n            pnpTerms.forEach(pnpTerm => {\n                const pickerTerm: IPickerTerm = {\n                    key: TermStorePickerServiceHelper.cleanGuid(pnpTerm.Id),\n                    name: pnpTerm.Name,\n                    path: pnpTerm.PathOfTerm,\n                    termSet: '',\n                    termGroup: ''\n                };\n                returnTerms.push(pickerTerm);\n\n                pnpTerm.termSet.group.inBatch(batch).usingCaching().get().then(pnpTermGroup => {\n                     pickerTerm.termGroup = TermStorePickerServiceHelper.cleanGuid(pnpTermGroup.Id);\n                 });\n\n                 pnpTerm.termSet.inBatch(batch).usingCaching().get().then(pnpTermSet => {\n                     pickerTerm.termSet = TermStorePickerServiceHelper.cleanGuid(pnpTermSet.Id);\n                     pickerTerm.termSetName = pnpTermSet.Name;\n                 });\n\n                 if (this.props.includeLabels) {\n                     pnpTerm.labels.inBatch(batch).usingCaching().get().then(labels => {\n                         pickerTerm.labels = labels.map(label => label.Value);\n                     });\n                 }\n            });\n\n            await batch.execute();\n        }\n\n        return returnTerms;\n    }\n\n    /**\n     * Searches for terms by provided text in specified term sets\n     * @param pnpTermStore Term Store\n     * @param pnpTermSets term sets where the terms should be searched for\n     * @param searchText text to search\n     * @param termGroupId Id of the group that contains the term sets\n     */\n    private async _searchTermsInTermSets(pnpTermStore: ITermStoreData & PnPTermStore, pnpTermSets: (ITermSetData & PnPTermSet)[], searchText: string, termGroupId?: string): Promise<IPickerTerm[]> {\n        const returnTerms: IPickerTerm[] = [];\n        const termSetGroups: { [key: string]: string } = {};\n        const termsBatch = taxonomy.createBatch();\n        const labelsBatch = taxonomy.createBatch();\n        const lowerCasedSearchText = searchText.toLowerCase();\n\n        for (let termSetIdx = 0, termSetLen = pnpTermSets.length; termSetIdx < termSetLen; termSetIdx++) {\n            const pnpTermSet = pnpTermSets[termSetIdx];\n            const pnpTermSetGuid = TermStorePickerServiceHelper.cleanGuid(pnpTermSet.Id);\n\n            if (!termGroupId) { // if no group id provided we need to load it from store\n                pnpTermSet.group.inBatch(termsBatch).usingCaching().get().then(pnpTermGroup => {\n                    termSetGroups[pnpTermSet.Id] = pnpTermGroup.Id;\n\n                    const loadedTerms = returnTerms.filter(t => t.termSet === pnpTermSetGuid);\n                    loadedTerms.forEach(t => {\n                        t.termGroup = TermStorePickerServiceHelper.cleanGuid(pnpTermGroup.Id);\n                    });\n                });\n            }\n\n            // getting terms for term set in batch\n            pnpTermSet.terms.inBatch(termsBatch).usingCaching().get().then(pnpTerms => {\n                for (let termIdx = 0, termLen = pnpTerms.length; termIdx < termLen; termIdx++) {\n                    const pnpTerm = pnpTerms[termIdx];\n                    if (pnpTerm.Name.toLowerCase().indexOf(lowerCasedSearchText) === 0) {\n                        const pickerTerm: IPickerTerm = {\n                            key: TermStorePickerServiceHelper.cleanGuid(pnpTerm.Id),\n                            name: pnpTerm.Name,\n                            path: pnpTerm.PathOfTerm,\n                            termSet: TermStorePickerServiceHelper.cleanGuid(pnpTermSetGuid),\n                            termSetName: pnpTermSet.Name,\n                            termGroup: termGroupId || TermStorePickerServiceHelper.cleanGuid(termSetGroups[pnpTermSet.Id])\n                        };\n                        returnTerms.push(pickerTerm);\n\n                        // getting labels for each term in a separate batch\n                        if (this.props.includeLabels) {\n                            pnpTerm.labels.inBatch(labelsBatch).usingCaching().get().then(pnpLabels => {\n                                pickerTerm.labels = pnpLabels.map(l => l.Value);\n                            });\n                        }\n                    }\n                }\n            });\n        }\n\n        //\n        // executing batches\n        //\n        await termsBatch.execute();\n        if (this.props.includeLabels) {\n            await labelsBatch.execute();\n        }\n\n        return returnTerms;\n    }\n\n    /**\n     * Ensures (loads if needed) term stores and term groups from taxonomy service\n     */\n    private async _ensureTermStores(): Promise<void> {\n        if (!this._pnpTermStores) {\n            this._pnpTermStores = await taxonomy.termStores.usingCaching().get();\n\n            // TODO: limit by group or termset\n            for (let i = 0, len = this._pnpTermStores.length; i < len; i++) {\n                const pnpTermStore = this._pnpTermStores[i];\n\n                let pnpGroups: (ITermGroupData & PnPTermGroup)[];\n\n                if (this.props.limitByGroupNameOrID) {\n                    const group = await this._requestPnPTermGroupByNameOrId(pnpTermStore, this.props.limitByGroupNameOrID);\n                    pnpGroups = [];\n                    if (group) {\n                        pnpGroups.push(group);\n                    }\n                }\n                else if (this.props.limitByTermsetNameOrID) {\n                    const pnpTermSets = await this._getPnPTermSetsByNameOrId(pnpTermStore, this.props.limitByTermsetNameOrID);\n                    pnpGroups = [];\n                    const groupsBatch = taxonomy.createBatch();\n                    pnpTermSets.forEach(pnpTermSet => {\n                        pnpTermSet.group.inBatch(groupsBatch).usingCaching().get().then(pnpGroup => {\n                            if (!pnpGroups.filter(gr => gr.Id === pnpGroup.Id).length) {\n                                pnpGroups.push(pnpGroup);\n                            }\n                        });\n                    });\n\n                    await groupsBatch.execute();\n                }\n                else {\n                    pnpGroups = await pnpTermStore.groups.usingCaching().get();\n                }\n\n                this._pnpGroups[pnpTermStore.Id] = pnpGroups;\n            }\n        }\n    }\n\n    /**\n     * Converts @pnp/sp-taxonomy Term Set instance into internal ITermSet object\n     * @param pnpTermSet @pnp/sp-taxonomy Term Set instance\n     * @param groupId Id of the group that contains the term set\n     */\n    private _pnpTermSet2TermSet(pnpTermSet: (ITermSetData & PnPTermSet), groupId: string): ITermSet {\n        const anyPnPTermSet: any = pnpTermSet as any; // we need this one to reference _ObjectType_ and _ObjectIdentity_\n        return {\n            _ObjectType_: anyPnPTermSet._ObjectType_,\n            _ObjectIdentity_: anyPnPTermSet._ObjectIdentity_,\n            Id: TermStorePickerServiceHelper.cleanGuid(pnpTermSet.Id),\n            Name: pnpTermSet.Name,\n            Description: pnpTermSet.Description,\n            Names: pnpTermSet.Names,\n            Group: groupId\n        };\n    }\n\n    /**\n     * Converts @pnp/sp-taxonomy Term Group instance into internal IGroup object\n     * @param pnpTermGroup @pnp/sp-taxonomy Term Group instance\n     * @param pnpTermStore @pnp/sp-taxonumy term store to work with\n     */\n    private _pnpTermGroup2TermGroup(pnpTermGroup: (ITermGroupData & PnPTermGroup), pnpTermStore: (ITermStoreData & PnPTermStore)): IGroup {\n        const anyPnPTermGroup: any = pnpTermGroup as any; // we need this one to reference _ObjectType_ and _ObjectIdentity_\n        return {\n            _ObjectType_: anyPnPTermGroup._ObjectType_,\n            _ObjectIdentity_: anyPnPTermGroup._ObjectIdentity_,\n            Id: TermStorePickerServiceHelper.cleanGuid(pnpTermGroup.Id),\n            Name: pnpTermGroup.Name,\n            IsSystemGroup: pnpTermGroup.IsSystemGroup,\n            TermStore: {\n                Id: TermStorePickerServiceHelper.cleanGuid(pnpTermStore.Id),\n                Name: pnpTermStore.Name\n            },\n            TermSets: {\n                _ObjectType_: this._termSetCollectionObjectType,\n                _Child_Items_: null\n            }\n        };\n    }\n\n    /**\n     * Gets term set(s) from taxonomy service by name or id\n     * @param pnpTermStore @pnp/sp-taxonumy term store to work with\n     * @param termSetNameOrID term set name or id\n     */\n    private async _getPnPTermSetsByNameOrId(pnpTermStore: (ITermStoreData & PnPTermStore), termSetNameOrID: string): Promise<(ITermSetData & PnPTermSet)[]> {\n        let pnpTermSets: (ITermSetData & PnPTermSet)[];\n        const isGuid = TermStorePickerServiceHelper.isGuid(termSetNameOrID);\n        //\n        // getting term sets by filter\n        //\n        if (isGuid) {\n            pnpTermSets = [];\n            const pnpTermSet = await pnpTermStore.getTermSetById(termSetNameOrID).usingCaching().get();\n            if (pnpTermSet.Id) {\n                pnpTermSets.push(pnpTermSet);\n            }\n        }\n        else {\n            pnpTermSets = await pnpTermStore.getTermSetsByName(termSetNameOrID, pnpTermStore.DefaultLanguage).usingCaching().get();\n        }\n\n        return pnpTermSets;\n    }\n\n    /**\n     * Gets group from cached (previously loaded) list of groups by name or id\n     * @param termStoreId term store id\n     * @param groupNameOrID group name or id\n     */\n    private _getPnPTermGroupsByNameOrId(termStoreId: string, groupNameOrID: string): (ITermGroupData & PnPTermGroup) {\n        const isGuid = TermStorePickerServiceHelper.isGuid(groupNameOrID);\n\n        const pnpTermStoreGroups = this._pnpGroups[termStoreId];\n        if (pnpTermStoreGroups) {\n            const groups = pnpTermStoreGroups.filter(pnpGroup =>\n                isGuid ? TermStorePickerServiceHelper.cleanGuid(pnpGroup.Id) === groupNameOrID\n                    : pnpGroup.Name === groupNameOrID);\n            if (groups && groups.length) {\n                return groups[0];\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Gets group from taxonomy service by name or id\n     * @param pnpTermStore @pnp/sp-taxonomy term store to work with\n     * @param groupNameOrID group name or id\n     */\n    private async _requestPnPTermGroupByNameOrId(pnpTermStore: (ITermStoreData & PnPTermStore), groupNameOrID: string): Promise<(ITermGroupData & PnPTermGroup)> {\n        const isGuid = TermStorePickerServiceHelper.isGuid(groupNameOrID);\n\n        let group: ITermGroupData & PnPTermGroup;\n        if (isGuid) {\n            group = await pnpTermStore.getTermGroupById(groupNameOrID).usingCaching().get();\n        }\n        else {\n            group = await pnpTermStore.groups.getByName(groupNameOrID).usingCaching().get();\n        }\n\n        if (group.Id) {\n            return group;\n        }\n\n        return null;\n    }\n}\n"],"sourceRoot":"../../src"}